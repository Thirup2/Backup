为了能编写处理不同数量实参的函数，C++11提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板。
## 一. initializer_list形参
如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用**initializer_list**类型的形参。`initializer_list`是一种标准库类型，用于表示某种特定类型的值的数组。`initializer_list`类型定义在同名的头文件中，它提供的操作如下表所示：

|操作|效果|
|:-:|:-:|
|`initializer_list<T> lst;`|默认初始化；T类型元素的空列表|
|`initializer_list<T> lst{a, b, c, ...};`|lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const|
|`lst2(lst)`、`lst2 = lst`|拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素|
|`lst.size()`|列表中的元素数量|
|`lst.begin()`|返回指向lst中首元素的指针|
|`lst.end()`|返回指向lst中尾元素下一位置的指针|

和vector一样，`initializer_list`也是一种模板类型，定义`initializer_list`对象时，必须说明列表中所含元素的类型。
和vector不一样的是，`initializer_list`对象中的元素永远是常量值，我们无法改变`initializer_list`对象中元素的值。
使用方法如下：
```c++
void error_msg(initializer_list<string> il) { /* ... */ }
```
传递参数的方式是在调用该函数的函数内定义一个相同类型的对象，然后在该对象里装入值后就可以作为参数传入了。或者直接在调用函数时使用花括号括起来的初始化列表来提供初始值。
处理该对象的方法是使用成员函数begin()和end()。

## 二. 省略符形参
主要为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为`varargs`的C标准库功能。
省略符形参只能出现在形参列表的最后一个位置，它的形式为以下两种：
```c++
void foo(parm_list, ...);
void foo(...);
```
**注意**：省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。