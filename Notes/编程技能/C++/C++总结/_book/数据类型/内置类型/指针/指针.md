## 一. 方法
通过在声明的标识符前添加解引用符（`*`）来创建指针。
```c++
int *ip1, *ip2;
double dp, *dp2;
```

## 二. 类型及大小
类型：指针存放某个对象的地址
大小：所有类型的指针的大小都相同，因为它们都保存的是地址，指针的大小通常由机器决定。由于指针有大小，所以指针本身也是对象。
## 三. 字面值
### 1. 某对象的地址
对某对象使用**取地址符**（`&`）即可获得该对象的地址，如：
```c++
int ival = 42;
int *p = &ival;
```

### 2. 空指针
1. 直接初始化为0：
    ```c++
    int *p1 = 0;
    ```
2. 用`nullptr`初始化
    ```c++
    int *p2 = nullptr;
    ```
3. 用`NULL`初始化
    ```c++
    int *p3 = NULL;
    ```

这3种方法都将指针值设置为0，即不指向任何对象。
`nullptr`是一种特殊类型的字面值，而`NULL`是定义在头文件cstdlib中的预处理器变量

### 3. 无效指针
上述情况之外的的其他值。
如果在声明指针时不初始化将对指针进行默认初始化。若其定义在所有函数体外时，其值为0；若其定义在函数体内时，其值为垃圾，即无效指针

## 四. 操作
### 1. 获取对象的地址
通过对对象进行取址来获取对象的地址：
```c++
int ival = 42;
int *p = &ival;
```

### 2. 使用指针访问对象
通过解引用操作符（`*`）来访问对象，前提是指针已经指向了一个对象：
```c++
int ival = 42;
int *p = &ival;    // 让指针p指向ival
cout << *p;        // 访问ival，*p即ival的值
```

### 3. 对指针赋值
对指针本身赋值将改变指针的指向，但原来指向的内容并不改变，只能用指针字面值或同类指针给指针赋值：
```c++
int i = 42;
int *pi = 0;        // 用字面值为指针pi赋值
int *pi2 = &i;      // 用字面值为指针pi2赋值
int *pi3 = pi2;     // 用同类指针为指针pi3赋值
```
对解引用后的指针赋值将改变指针指向的内容，但其指向不会改变。
```c++
*pi = 0;       // 对pi指向的对象赋值0，由于pi是空指针，将产生错误
*pi2 = 0；     // 将pi2指向的对象i赋值为0
*pi3 = 42；    // 将pi3指向的对象i赋值为42
```

### 4. 指针的比较
1. 指针的逻辑值：如果指针的值是0，则其为false，否则都是true
2. 指针的比较：对于两个同类型的合法指针，可以用相等操作符（`==`）或不相等操作符（`!=`）来比较它们。若两指针存放的地址值相同，则它们相等，反之它们不相等

## 五. 其他类型
### 1. void *指针
可以存放任意对象的地址。利用`void *`指针能做的事比较有限：
1. 拿它和别的指针比较
2. 作为函数的输入或输出
3. 赋给另外一个`void *`指针

### 2. 指向指针的指针
通过`*`的个数可以区分指针的级别。也就是说，`**`表示指向指针的指针，`***`表示指向指针的指针的指针，以此类推：
```c++
int ival = 1024;
int *pi = &ival;    // pi指向ival
int **ppi = &pi;    // ppi指向pi
```

### 3. 指向指针的引用
由于引用本身不是对象，所以无法定义指向引用的指针，但是可以定义指向指针的引用：
```c++
int i = 42;
int *p;
int *&r = p;        // r是一个对指针p的引用
```