# 一. 简介
访问容器元素的两个方法，一个是下标引用，一个就是**迭代器**
所有标准库容器都可以使用迭代器，但只有少数几种才同时支持下标运算符。
string虽然不属于容器类型，但是string支持很多和容器类型类似的操作，所以string也可以使用迭代器。
迭代器有有效和无效之分：
1. 有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置
2. 除了有效的其他所有情况都属于无效

# 二. 使用迭代器
## 1. 迭代器类型
`string`对象的迭代器类型是`string::iterator`类型。
如果对象是常量，则其迭代器类型是`string::const_iterator`类型。
对于`iterator`迭代器，可以读写迭代器指向的元素，对于`const_iterator`迭代器，只可以读迭代器指向的元素。

## 2. 使用迭代器
通过两个成员函数来返回迭代器：
```c++
string s("Hello World!");
auto begin = s.begin();
auto end = s.end();
```
- s.begin()：返回指向对象`s`第一个元素即字符的迭代器
- s.end()：返回指向对象`s`最后一个元素的下一个位置的迭代器

# 三. 迭代器操作
下表是迭代器类型支持的操作，其中`iter`是迭代器：

|操作|效果|
|:-:|:-:|
|`*iter`|返回迭代器所指元素的引用|
|`iter->mem`|解引用`iter`并获取该元素的名为`mem`的成员，等价于`(*iter).mem`|
|`++iter`|令`iter`指示容器中的下一个元素|
|`--iter`|令`iter`指示容器的上一个元素|
|`iter1 == iter2`，`iter != iter2`|判断两个迭代器是否相等（不相等）|

**注意**：
1. 如果迭代器所指对象的类型是类类型，可以使用`->`操作符访问其成员
2. 试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为
3. 迭代器的相等性判断只有当两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等；反之，则不等。
4. 在使用了迭代器的循环体中，任何一种可能改变对象容量的操作，都会使该对象的迭代器失效。

# 四. 迭代器运算
string支持的迭代器运算如下表：

|运算|效果|
|:-:|:-:|
|`iter+n`|运算所得的值为一个迭代器，该迭代器指向的位置在`iter`指向位置的前`n`个|
|`iter-n`|运算所得的值为一个迭代器，其位置与`iter+n`相反|
|`iter+=n`|`iter`指向的位置向前移动n个元素位置|
|`iter-=n`|与`iter+=n`相反|
|`iter1-iter2`|运算所得的值为两迭代器之间的距离，单位为元素。参与运算的两个迭代器必须指向同一个容器中的元素或尾元素的下一位置|
|`>`，`>=`，`<`，`<=`|如果某迭代器指向的容器位置在另一个迭代器所指的位置之前，则说前者小于后者。参与运算的两个迭代器必须指向同一个容器中的元素或者尾元素的下一位置|

**注意**：
1. 两迭代器相减的结果的类型为`string::difference_type`类型