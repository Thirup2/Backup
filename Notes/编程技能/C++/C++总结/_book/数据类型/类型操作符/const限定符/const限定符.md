如果希望变量的值定义之后就不能被改变，可以使用关键字`const`对变量的类型加以限定：
```c++
const int bufSize = 512;
```
这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误
**注意**：
1. 由于const对象一旦创建后其值就不能再改变，所以const对象必须初始化
2. 默认状态下，const对象仅在文件内有效。如果想要在文件之间共享，那么不论是声明还是定义都要添加`extern`关键字

## 一. const的引用
可以把引用绑定到const对象上，就像绑定到其他对象上一样。允许的情况有下面几种：
1. 将普通对象绑定到const引用
2. 将const对象绑定到const引用
3. 将字面值绑定到const引用
4. 将一般表达式绑定到const引用

如：
```c++
int i = 42;
const int n = 12;

const int &r1 = i;        // 将普通对象绑定到const引用
const int &r2 = n;        // 将const对象绑定到const引用
const int &r3 = 42;       // 将字面值绑定到const引用
const int &r4 = r1 * 2;   // 将一般表达式绑定到const引用
```
**注意**：将普通对象绑定到const引用时，无法通过引用修改对象本身，但可以通过其他途径修改<br/>
对于非第二种情况的其他3种情况，实际上执行了两步操作：
1. 创建一个与引用相同类型的const对象，并用等号后面的值对其进行初始化
2. 将创建的const对象与const引用绑定在一起

如：
```c++
double dval = 3.14;
const int &ri = dval;
```
等价于
```c++
double dval = 3.14;
const int temp = dval;        // 创建一个临时的整型常量，用dval初始化，只保留整数部分
const int &ri = temp;         // 将temp这个const对象绑定到const引用
```

## 二. 指针和const
对于指针的const有3种情况：
### 1. 对指针本身const
```c++
int *const p = 0;
```
在该情况下，对指针初始化之后，指针的指向就不能再改变，但是可以改变其指向的值
该情况下可以用于初始化指针的值有：
1. 同类型普通对象的地址
2. 同类型指向普通对象的任意指针
3. 空指针
### 2. 对指针指向的值const
```c++
int const *p = 0;
```
在该情况下，对指针初始化之后，指针的指向还可以改变，但是指向的值不能通过指针改变
该情况下可以用于初始化指针的值有：
1. 同类型任意对象的地址
2. 同类型指向任意对象的任意指针
3. 空指针
### 3. 对指针本身和其指向的值都const
```c++
int const *const p = 0;
```
在该情况下，对指针初始化之后，指针的指向和其指向的值都不能再改变，指向的值可以通过其他途径修改
该情况下可以用于初始化指针的值有：
1. 同类型任意对象的地址
2. 同类型指向任意对象的任意指针
3. 空指针

## 三. 顶层const和底层const
### 1. 概念
对于指针来说，指针本身是一个对象，它又可以指向另外一个对象。而**顶层const**表示指针本身是个常量，**底层const**表示指针所指的对象是一个常量。
更一般的情况是，**顶层const**可以表示任意的对象是常量，而**底层const**则与指针和引用等复合类型的基本类型部分有关。
**注意**：引用不可能具有顶层const，因为其并非一个对象。引用只可能具有底层const
### 2. 拷贝操作
- 顶层const：**顶层const对拷贝操作无影响**。
拷入的对象具有顶层const而拷出的对象不具有、考出的对象具有顶层const而拷入的对象不具有、拷入拷出的对象都具有顶层const以及拷入拷出的对象都不具有顶层const这4种情况拷贝操作都能顺利执行。
- 底层const：**当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行**。
具有底层const资格的对象可以以任何对象作为被拷贝对象，但不具有底层const资格的对象只能以不具有底层const资格的对象作为被拷贝对象