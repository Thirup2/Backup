## 一. 使用auto的原因
编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++ 11新标准引入了`auto`类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符不同，auto让编译器通过初始值来推算变量的类型。
**注意**：
1. auto定义的变量必须有初始值，因为需要判断类型。
2. 使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。

## 二. 复合类型的使用
### 1. 引用
使用引用实际上使用的是引用的对象，当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：
```c++
int i = 0, &r = i;
auto a = r;        // a是一个整数而非引用
```

### 2. const
auto一般会忽略掉顶层const，同时底层const会保留，如：
```c++
int i = 0;
const int ci = i, &cr = ci;
auto b = ci;        // ci是一个具有顶层const的整数，所以b是一个整数
auto c = cr;        // cr是一个引用，对象是ci，所以c是一个整数
auto d = &i;        // i是一个整数，解引用为指向整数的指针，所以d是一个指向整型的指针
auto e = &ci;       // ci是一个常量整数，解引用为指向常量整数的指针，具有底层const，所有e是一个指向常量整数的指针
```
如果希望推断出的auto类型是一个顶层const，需要明确指出：
```c++
const auto f = ci;
```

### 3. 引用和const
可以将引用的类型设为auto：
```c++
auto &g = ci;            // ci是一个具有顶层const的对象，所以g是一个整型常量引用
auto &h = 42;            // 错误：h为非常量引用绑定字面值
const auto &j = 42;      // 正确：j为常量引用，可以绑定字面值
```
- 设置一个类型为auto的引用时，初始值中的顶层常量属性不会忽略。因为给具有顶层const的初始值绑定一个引用时，该引用将被判定为底层const而不是顶层const，所以初始值的顶层const要保留
- 而第二条声明语句，42的类型是int，所以h被判定为整型引用而非整型常量引用