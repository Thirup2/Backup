# 一. 隐式转换
## 1. 隐式转换发生的情况
* 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型
* 在条件中，非布尔值转换成布尔类型
* 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
* 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
* 函数调用时也会发生类型转换

## 2. 算术转换
### 1). 整型提升
对于`bool`、`char`、`signed char`、`unsigned char`、`short`、`unsigned short`等类型来说，只要它们所有可能的值都能存在`int`里，它们就会提升成`int`类型；否则，提升成`unsigned int`类型。
对于`wchar_t`、`char16_t`、`char32_t`这几种类型来说，它们将提升成`int`、`usigned int`、`long`、`unsigned long`、`long long`、`unsigned long lone`中能容纳原类型所有可能的值的最小的一种类型

### 2). 无符号类型的运算对象
在进行整型提升之后，有3种情况：
1. 结果的类型匹配，无须进行进一步的转换
2. 如果提升后两个运算对象的类型要么都是带符号的、要么都是无符号的，但类型大小不一样，则小类型的运算对象转换成较大的类型
3. 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，又有以下两种情况：
    * 如果无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的
    * 如果无符号类型小于带符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

**注意**：无符号类型与带符号类型之间的转换如果涉及负数的转换，将产生错误效果

## 3. 其他隐式类型转换
### 1). 数组转换成指针
在大多数情况下，该转换将会执行。
当数组被用作`decltype`关键字的参数，或者作为取地址符、sizeof及typeid等运算符的运算对象时，上述转换不会发生。如果用一个引用来初始化数组，上述转换也不会发生。

### 2). 指针的转换
常量数值0或者字面值nullptr能转换成任意指针类型；
指向任意非常量的指针能转换成void*；
指向任意对象的指针能转换成const void *

### 3). 转换成布尔类型
在需要布尔值的地方，如果指针或算术类型的值为0，转换结果是false，否则是true

### 4). 转换成常量
允许将指向非常量类型的指针转换成指向相应的常量类型的指针；
对于引用也相同

### 5). 类类型定义的转换
类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。
如在需要标准库string类型的地方使用C风格字符串；在条件部分读入istream（将cin转换成布尔值）

# 二. 显式转换
在某些地方需要使用强制类型转换，如：
```c++
int i, j;
double slope = i / j;
```
如果按照隐式转换的规则，该表达式先进行整数除法，得到一个整数值，然后将整数值转换成double赋值给slope。

## 1. 命名的强制类型转换
一个命名的强制类型转换以如下形式写出：
```c++
cast_name<type>(expression);
```
- `type`：转换的目标类型，若`type`为引用类型，则结果是左值
- `expression`：待转换的值
- `cast-name`：是**static_cast**、**dynamic_cast**、**const_cast**和**reinterpret_cast**这四种中的一种

### 1). static_cast
任何具有明确定义的类型转换，只要不包含底层const，都可以使用`static_cast`。
`static_cast`可以实现C++中内置基本数据类型之间的相互转换，如果涉及到类，`static_cast`只能在由相互联系的类型中进行相互转换。
```c++
double slope = static_cast<double>(j) / i;

void *p = &d;
double *dp = static_cast<double*>(p);
```

### 2). dynamic_cast
支持运行时类型识别

### 3). const_cast
只能改变运算对象的底层const，所以只能对指针或引用使用，用于去掉它们的底层const性质。同时强制类型转换的类型除了const必须和表达式的类型相同。
```c++
const char *pc;
char *p = const_cast<char*>(pc);
```
**注意**：使用强制类型转换获得写权限是合法的，但是对对象执行写操作这件事不一定是合法的。如果对象是一个常量，对其执行写操作将会产生未定义的后果

### 4). reinterpret_cast
在C++语言中，`reinterpret_cast`主要有3种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转换为指针或引用类型。
其功能总结为：按照提供的`type`类型重新解释表达式类型
```c++
int *ip;
char *pc = reinterpret_cast<char *>(ip);
```
该例中把`ip`的类型从`int *`重新解释成了`char *`并赋给了`pc`指针，但是两个指针指向的地址都是相同的，对`pc`解引用将解释一个原本4个字节（如果int是4字节）内容中的第一个字节。

**注意**：我们必须牢记`pc`所指的真实对象是一个`int`而非字符，如果把`pc`当成普通的字符指针使用就可能在运行时发生错误。

## 2. 旧式的强制类型转换
在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：
```c++
type (expr);            // 函数形式的强制类型转换
(type) expr;            // C语言风格的强制类型转换
```
根据所涉及的类型不同，旧式的强制类型转换分别具有与`const_cast`、`static_cast`或`reinterpret_cast`相似的行为。