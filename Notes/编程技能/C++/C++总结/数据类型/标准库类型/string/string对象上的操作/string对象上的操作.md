# 一. 操作总览
对于string对象的大多数操作如下表，其中`os`为输出流，`is`为输入流，`s`为`string`对象：

|操作|效果|
|:-:|:-:|
|`os<<s`|将`s`写到输出流`os`中，返回`os`|
|`is>>s`|从`is`中读取字符串赋给`s`，字符串以空白分隔，返回`is`|
|`getline(is, s)`|从`is`中读取一行赋给`s`，返回`is`|
|`s.empty()`|`s`为空返回true，否则返回false|
|`s.size()`|返回`s`中字符的个数|
|`s[n]`|返回`s`中第n个字符的引用，位置n从0计起|
|`s1+s2`|返回`s1`和`s2`连接后的结果|
|`s1=s2`|用`s2`的副本代替`s1`中原来的字符|
|`s1==s2`，`s1!=s2`|如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感|
|`<`，`<=`，`>`，`>=`|利用字符在字典中的顺序进行比较，且对字母的大小写敏感|
|`s.begin()`|返回指向对象`s`第一个元素即字符的迭代器|
|`s.end()`|返回指向对象`s`最后一个元素的下一个位置的迭代器|
|`s.c_str()`|返回一个C风格的字符串|

# 二. 读写string对象

|操作|效果|
|:-:|:-:|
|`os<<s`|将`s`写到输出流`os`中，返回`os`|
|`is>>s`|从`is`中读取字符串赋给`s`，字符串以空白分隔，返回`is`|
|`getline(is, s)`|从`is`中读取一行赋给`s`，返回`is`|

## 1. 输出string对象
使用IO操作符输出string对象：
```c++
int main()
{
    string s("Hello World!");
    cout << s << endl;
    return 0;
}
```

## 2. 读取string对象
### 1). 使用IO操作符读取
```c++
int main()
{
    string s;
    cin >> s;
    cout << s << endl;
    return 0;
}
```
使用这种方法读取的字符串将从缓冲区第一个非空白字符开始读取，直到遇到下一个空白字符，结尾的空白字符不保存。
**注意**：使用这种方法读取，如果空白字符后面还有未读取的字符串，将留在缓冲区等待下一次读取。

### 2). 使用getline函数读取一整行
```c++
int main()
{
    string s;
    getline(cin, s);
    cout << s << endl;

    return 0;
}
```
- 参数：第一个参数是输入流，第二个参数是一个string对象
- 操作：函数从给定的输入流中读入内容并存入到string对象中，直到遇到换行符为止（*换行符也从缓冲区被读入函数，但是不保存到string对象中*）。如果输入的一开始就是换行符，那么所得的结果是个空string
- 返回值：和输入运算符一样，getline也会返回它的流参数。所以能用getline的结果作为条件。

# 三. empty和size
|操作|效果|
|:-:|:-:|
|`s.empty()`|`s`为空返回true，否则返回false|
|`s.size()`|返回`s`中字符的个数|

## 1. empty
下面这段程序只输出非空的行：
```c++
int main(void)
{
    string s;
    while(getline(cin, s))
        if(!s.empty())
            cout << s << endl;
    return 0;
}
```
- 操作：函数根据string对象是否为空返回一个对应的布尔值
- 返回值：布尔值。若对象为空，返回true，否则返回false

## 2. size
下面这段程序只输出长度超过80个字符的行：
```c++
int main()
{
    string line;
    while(getline(cin, line))
        if(line.size() > 80)
            cout << line << endl;
    return 0;
}
```
- 操作：返回string对象的长度，即string对象中字符的个数
- 返回值：string::size_type类型

### 1) string::size_type类型
`string`类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型**size_type**即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字`size_type`是在类string中定义的。
`string::size_type`类型的细节并不清楚，但有一点是肯定的：它是一个无符号类型的值而且能足够放下任何`string`对象的大小。所有用于存放`string`类的`size`函数返回值的变量，都应该是`string::size_type`类型的
在C++ 11标准中，允许编译器通过`auto`或`decltype`来推断变量的类型：
```c++
auto len = line.size();
```
**注意**：由于`size`函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的效果。

# 四. 比较string对象
|操作|效果|
|:-:|:-:|
|`s1==s2`，`s1!=s2`|如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感|
|`<`，`<=`，`>`，`>=`|利用字符在字典中的顺序进行比较，且对字母的大小写敏感|

## 1. 字符串的比较方法
### 1). 比较方法
1. 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。
2. 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

### 2). 注意点
1. 比较按照字典顺序，即排在前面的较小，排在后面的较大
2. 对于字符串的比较，是大小写敏感的，同一个字母的小写形式大于大写形式

# 五. 修改string对象
|操作|效果|
|:-:|:-:|
|`s1+s2`|返回`s1`和`s2`连接后的结果|
|`s1=s2`|用`s2`的副本代替`s1`中原来的字符|

## 1. 为string对象赋值
对于string而言，允许把一个对象的值赋给另外一个对象：
```c++
string s1, s2;
s1 = 'a';
s1 = "Value"；
s2 = s1;
```
**注意**：标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代

## 2. 两个string对象相加
两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。
也就是说，对string对象使用加法运算符的结果是一个新的string对象，它所包含的字符由两部分组成：前半部分是加号左侧string对象所含的字符、后半部分是加号右侧对象所含的字符。
复合赋值运算符负责把右侧string对象的内容追加到左侧string对象的后面：
```c++
string s1 = "hello, ";
string s2 = "world\n";
string s3;
s3 = s1 + s2;        // s3的内容是hello world\n
s1 += s2;              // s1的内容是hello world\n
```

## 3. 字面值和string对象相加
**规则**：当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧运算对象至少有一个是string。原因是因为只有两个string对象才能相加，两个字面值之间没有加法操作。当加法两侧的对象是一个string对象和一个字面值时，字面值会转换为string对象，而当加法两侧的对象是两个字面值时，字面值不会进行转换。
```c++
string s1 = "hello";                    // 正确。字符串字面值转换为string对象
string s2 = "world";                    // 正确。字符串字面值转换为string对象
string s3 = s1 + ", " + s2 + '\n';      // 正确。每一个加法的结果都是string对象
string s4 = s1 + ", ";                  // 正确。字符串字面值转换为string对象
string s5 = "hello" + ", ";             // 错误。字符串字面值无法转换为string对象
string s6 = s1 + ", " + "world";        // 正确。第一个加法运算的结果是string对象
string s7 = "hello" + ", " + s2;        // 错误。第一个加法两侧的字面值无法转换
```
**注意**：C++中当表达式是多个加法运算并列时，其运算顺序是从左到右执行，每一个加法运算返回其结果