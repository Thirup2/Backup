# 一. 简介
标准库类型**vector**表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为`vector`“容纳着”其他对象，所以它也常被称作**容器**。
- 使用`vector`，必须包含头文件`<vector>`。
- `vector`定义在命名空间`std`中，使用时须声明

C++语言既有类模板，也有函数模板，`vector`是一个**类模板**。
模板本身不是类或函数，编译器根据模板创建类或函数的过程称为**实例化**。
当使用模板时，需要指出编译器应把类或函数实例化成何种类型。
对于类模板来说，我们通过一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式是：在模板名字后面跟一对尖括号，在括号内放上信息。
如：
```c++
vector<int> ivec;
vector<Sales_item> Sales_vec;
vector<vector<string>> file;
```
在上面的例子中，编译器根据模板生成了三种不同的类型：`vector<int>`、`vector<Sales_item>`、`vector<vector<string>>`。
`vector`能容纳绝大多数类型的对象作为其元素，由于引用不是对象，所以不存在包含引用的`vector`。
> - **C++ 11**：在C++ 11之前的标准中，如果`vector`的元素还是`vector`（或者其他模板类型），则其定义的形式必须在外层`vector`对象的右尖括号和其元素类型之间添加一个空格。而C++ 11不用这么做

# 二. 定义和初始化
## 1. 定义
```c++
vector<Type> name;
```
name就是一个`vector<Type>`对象

## 2. 初始化
下表列出了定义vector对象的常用方法：

|方法|含义|
|:-:|:-:|
|`vector<T> v1`|默认初始化，`v1`是一个空`vector`，它潜在的元素是`T`类型的|
|`vector<T> v2(v1)`|用`v1`初始化`v2`|
|`vector<T> v2 = v1`|等价于`v2(v1)`|
|`vector<T> v3(n, val)`|`v3`包含了`n`个重复的元素，每个元素的值都是`val`|
|`vector<T> v4(n)`|`v4`包含了`n`个重复地执行了值初始化的对象|
|`vector<T> v5{a, b, c...}`|`v5`包含了初始值个数的元素，每个元素被赋予相应的初始值|
|`vector<T> v5 = {a, b, c...}`|等价于`v5{a, b, c...}`|
|`vector<T> v6(begin(arr), end(arr))`|使用数组初始化vector对象|

### 1). 默认初始化
`v1`执行默认初始化
`vector`的默认初始化将创建一个指定类型的空`vector`

### 2). 对象初始化
`v2`执行对象初始化
可以将一个`vector`对象用来初始化新的`vector`对象，前提是两个`vector`对象类型相同

### 3). 列表初始化
`v5`执行列表初始化
花括号里的元素个数就是初始化后`vector`的元素个数，花括号里每个元素的值就是初始化后`vector`中每个元素的值

### 4). 值初始化
`v3`、`v4`执行值初始化
通过在圆括号里输入元素个数、元素值两个参数可以执行值初始化，元素值有时可以省略。其初始化结果是，在`vector`对象中添加相应个数元素，每个元素的元素值都是第二个参数指定的元素值。
在第二个参数省略的情况下：
- 如果`vector`对象的元素是内置类型，则元素初始值自动设为0。
- 如果`vector`对象的元素是某种类类型，则元素由类默认初始化。如果类要求必须明确地提供初始值，则必须提供初始的元素值。

### 5). 例外
如果使用花括号进行初始化，但是提供的值无法执行列表初始化，初始化过程会考虑其他的初始化方式。
如：
```c++
vector<string> v7{10};
vector<string> v8{10, "hi"};
```
虽然使用了花括号的形式，但10不能用来初始化字符串，于是被解释为了值初始化，`v7`包含10个执行默认初始化的字符串，`v8`包含10个初始化为“hi”的字符串。